% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00roxygen.R, R/osa.R
\name{OSA-residuals}
\alias{OSA-residuals}
\alias{oneStepPredict}
\alias{OSA}
\alias{[.osa}
\title{Recursive quantile residuals}
\usage{
oneStepPredict(
  obj,
  observation.name = names(obj$env$osa)[1],
  data.term.indicator = "_RTMB_keep_",
  ...
)

OSA(x)

\method{[}{osa}(x, ...)
}
\arguments{
\item{obj}{TMB model object (output from \code{MakeADFun})}

\item{observation.name}{Auto detected - use the default}

\item{data.term.indicator}{Auto detected - use the default}

\item{...}{Passed to \code{TMB::oneStepPredict} - \bold{please carefully read the documentation}, especially the \code{method} argument.}

\item{x}{Observation object}
}
\description{
OSA residuals are computed using the function
\code{oneStepPredict}. For this to work, you need to mark the
observation inside the objective function using the \code{OSA}
function. Thereafter, residual calculation is as simple as
\code{oneStepPredict(obj)}. However, you probably want specify a
\code{method} to use.
}
\section{Functions}{
\itemize{
\item \code{oneStepPredict()}: Calculate the residuals. See documentation of \code{?TMB::oneStepPredict}.

\item \code{OSA()}: Mark observation to be used by \code{oneStepPredict}.
If your objective function is using an observation \code{obs}, you simply need
to run \code{obs <- OSA(obs)} \emph{inside the objective function}.
This will allow \code{oneStepPredict} to change the class of \code{obs} to
\code{"osa"} on request.

\item \code{[}: Subset observations marked for OSA calculation.
This function makes sure that when you subset an observation of class \code{"osa"} such as
\code{obs <- new("osa", x=advector(matrix(1:10,2)), keep = cbind(rep(TRUE,10),FALSE,FALSE))}
the 'keep' attribute will be adjusted accordingly
\code{obs[,1:2]}

}}
\examples{
set.seed(1)
rw <- cumsum(.5*rnorm(100))
obs <- rpois(100, lambda=exp(rw))
obj <- MakeADFun(function(p) {
  obs <- OSA(obs)
  ans <- 0
  jump <- c(p$rw[1], diff(p$rw))
  ans <- ans - sum(dnorm(jump, sd=p$sd, log=TRUE))
  ans <- ans - sum(dpois(obs, lambda=exp(p$rw), log=TRUE))
  ans
}, parameters=list(rw=rep(0,100), sd=1), random="rw")
nlminb(obj$par, obj$fn, obj$gr)
res <- oneStepPredict(obj, method="oneStepGeneric", discrete=TRUE, range=c(0,Inf))$residual
}
