% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00roxygen.R, R/S4methods.R, R/complex.R
\name{ADvector}
\alias{ADvector}
\alias{ifelse,logical,advector,advector-method}
\alias{advector}
\alias{Ops.advector}
\alias{Math.advector}
\alias{as.vector.advector}
\alias{aperm.advector}
\alias{c.advector}
\alias{[.advector}
\alias{[<-.advector}
\alias{[[.advector}
\alias{rep.advector}
\alias{sum.advector}
\alias{prod.advector}
\alias{is.numeric.advector}
\title{The AD vector and its methods}
\usage{
\S4method{ifelse}{logical,advector,advector}(test, yes, no)

advector(x)

\method{Ops}{advector}(e1, e2)

\method{Math}{advector}(x, ...)

\method{as.vector}{advector}(x, mode = "any")

\method{aperm}{advector}(a, perm, ...)

\method{c}{advector}(...)

\method{[}{advector}(x, ...)

\method{[}{advector}(x, ...) <- value

\method{[[}{advector}(x, ...)

\method{rep}{advector}(x, ...)

\method{sum}{advector}(x, ..., na.rm)

\method{prod}{advector}(x, ..., na.rm)

\method{is.numeric}{advector}(x)
}
\arguments{
\item{test}{See \code{base::ifelse}}

\item{yes}{See \code{base::ifelse}}

\item{no}{See \code{base::ifelse}}

\item{x}{numeric or advector}

\item{e1}{advector}

\item{e2}{advector}

\item{...}{Additional arguments}

\item{mode}{FIXME might not be handled correctly by \code{as.vector}}

\item{a}{advector with dimension attribute}

\item{perm}{Permutation as in \code{aperm}}

\item{value}{Replacement value implicitly converted to AD}

\item{na.rm}{Must be FALSE (default)}
}
\description{
An \code{advector} is a class used behind the scenes to replace
normal R numeric objects during automatic differentiation. An
\code{advector} has a 'temporary lifetime' and therefore you do not
\emph{see} / \emph{need to know} it as a normal user.
}
\details{
An AD vector (class='advector') is an atomic R vector of 'codes'
that are internally interpretable as 'AD scalars'. A substantial
part of R's existing S3 matrix and array functionality can be
re-used for AD vectors.
}
\section{Functions}{
\itemize{
\item \code{ifelse(test = logical, yes = advector, no = advector)}: As \code{base::ifelse}

\item \code{advector()}: Construct a new advector

\item \code{Ops(advector)}: Binary operations

\item \code{Math(advector)}: Unary operations

\item \code{as.vector(advector)}: Makes \code{array(x)} work.

\item \code{aperm(advector)}: Equivalent of \link[base]{aperm}

\item \code{c(advector)}: Equivalent of \link[base]{c}

\item \code{[}: Equivalent of \link[base]{"["}

\item \code{`[`(advector) <- value}: Equivalent of \link[base]{"[<-"}

\item \code{[[}: Equivalent of \link[base]{"[["}

\item \code{rep(advector)}: Equivalent of \link[base]{rep}. Makes \code{outer(x,x,...)} work.

\item \code{sum(advector)}: Equivalent of \link[base]{sum} except \code{na.rm} not allowed.

\item \code{prod(advector)}: Equivalent of \link[base]{prod} except \code{na.rm} not allowed.

\item \code{is.numeric(advector)}: Makes \code{cov2cor()} work. FIXME: Any unwanted side-effects with this?

}}
\examples{
x <- advector(1:9)
a <- array(x, c(3,3))  ## as an array
outer(x, x, "+") ## Implicit via 'rep'
rev(x)           ## Implicit via '['
}
