% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00roxygen.R, R/distributions.R, R/sim.R
\name{Simulation}
\alias{Simulation}
\alias{dexp,simref,ANY,ANY-method}
\alias{dweibull,simref,ANY,ANY,ANY-method}
\alias{dbinom,simref,ANY,ANY,ANY-method}
\alias{dbeta,simref,ANY,ANY,ANY,ANY-method}
\alias{df,simref,ANY,ANY,ANY,ANY-method}
\alias{dlogis,simref,ANY,ANY,ANY-method}
\alias{dt,simref,ANY,ANY,ANY-method}
\alias{dnbinom,simref,ANY,ANY,ANY,ANY-method}
\alias{dpois,simref,ANY,ANY-method}
\alias{dgamma,simref,ANY,ANY,ANY,ANY-method}
\alias{simref}
\alias{dim<-.simref}
\alias{length.simref}
\alias{dim.simref}
\alias{is.array.simref}
\alias{is.matrix.simref}
\alias{as.array.simref}
\alias{is.na.simref}
\alias{[.simref}
\alias{[<-.simref}
\alias{Ops.simref}
\alias{Math.simref}
\alias{t.simref}
\alias{diff.simref}
\alias{Summary.simref}
\title{Simulation}
\usage{
\S4method{dexp}{simref,ANY,ANY}(x, rate = 1, log = FALSE)

\S4method{dweibull}{simref,ANY,ANY,ANY}(x, shape, scale = 1, log = FALSE)

\S4method{dbinom}{simref,ANY,ANY,ANY}(x, size, prob, log = FALSE)

\S4method{dbeta}{simref,ANY,ANY,ANY,ANY}(x, shape1, shape2, log)

\S4method{df}{simref,ANY,ANY,ANY,ANY}(x, df1, df2, log)

\S4method{dlogis}{simref,ANY,ANY,ANY}(x, location = 0, scale = 1, log = FALSE)

\S4method{dt}{simref,ANY,ANY,ANY}(x, df, log)

\S4method{dnbinom}{simref,ANY,ANY,ANY,ANY}(x, size, prob, log)

\S4method{dpois}{simref,ANY,ANY}(x, lambda, log = FALSE)

\S4method{dgamma}{simref,ANY,ANY,ANY,ANY}(x, shape, scale, log)

simref(n)

\method{dim}{simref}(x) <- value

\method{length}{simref}(x)

\method{dim}{simref}(x)

\method{is.array}{simref}(x)

\method{is.matrix}{simref}(x)

\method{as.array}{simref}(x, ...)

\method{is.na}{simref}(x)

\method{[}{simref}(x, ...)

\method{[}{simref}(x, ...) <- value

\method{Ops}{simref}(e1, e2)

\method{Math}{simref}(x)

\method{t}{simref}(x)

\method{diff}{simref}(x, lag = 1L, differences = 1L, ...)

\method{Summary}{simref}(..., na.rm = FALSE)
}
\description{
An RTMB objective function can be run in 'simulation mode' where normal likelihood evaluation is replaced by corresponding random number generation. This facilitates automatic simulation under some restrictions.
}
\details{
In simulation mode all log density evaluation, involving either random effects or oberservations, is interpreted as probability assignment.

\bold{direct vs indirect} Assignments can be 'direct' as for example

\code{dnorm(u, log=TRUE)      ## u ~ N(0, 1)}

or 'indirect' as in

\code{dnorm(2*u+1, log=TRUE)  ## u ~ N(-1, .5)}

Indirect assignment works for a limited set of easily invertible functions - see \code{methods(class="simref")}.

\bold{Simulation order} Note that probability assignments are sequential: All information required to draw a new variable must already be simulated.
For example the assignment

\code{dnorm(diff(u), log=TRUE)}

is not valid without a prior specification

\code{dnorm(u[1], log=TRUE)}

\bold{Supported distributions} Assignement must use supported density functions. I.e.

\code{dpois(N, exp(u), log=TRUE)}

cannot be replaced by

\code{N * u - exp(u)}

The latter will have no effect in simulation mode (the simulation will be \code{NA}).
}
\section{Functions}{
\itemize{
\item \code{dexp(x = simref, rate = ANY, log = ANY)}: Simulation implementation

\item \code{dweibull(x = simref, shape = ANY, scale = ANY, log = ANY)}: Simulation implementation

\item \code{dbinom(x = simref, size = ANY, prob = ANY, log = ANY)}: Simulation implementation

\item \code{dbeta(x = simref, shape1 = ANY, shape2 = ANY, ncp = ANY, log = ANY)}: Simulation implementation

\item \code{df(x = simref, df1 = ANY, df2 = ANY, ncp = ANY, log = ANY)}: Simulation implementation

\item \code{dlogis(x = simref, location = ANY, scale = ANY, log = ANY)}: Simulation implementation

\item \code{dt(x = simref, df = ANY, ncp = ANY, log = ANY)}: Simulation implementation

\item \code{dnbinom(x = simref, size = ANY, prob = ANY, mu = ANY, log = ANY)}: Simulation implementation

\item \code{dpois(x = simref, lambda = ANY, log = ANY)}: Simulation implementation

\item \code{dgamma(x = simref, shape = ANY, rate = ANY, scale = ANY, log = ANY)}: Simulation implementation

\item \code{simref()}: Construct \code{simref}

\item \code{dim(simref) <- value}: Equivalent of \link[base]{"dim<-"}

\item \code{length(simref)}: Equivalent of \link[base]{length}

\item \code{dim(simref)}: Equivalent of \link[base]{dim}

\item \code{is.array(simref)}: Equivalent of \link[base]{is.array}

\item \code{is.matrix(simref)}: Equivalent of \link[base]{is.matrix}

\item \code{as.array(simref)}: Equivalent of \link[base]{as.array}

\item \code{is.na(simref)}: Equivalent of \link[base]{is.na}

\item \code{[}: Equivalent of \link[base]{"["}

\item \code{`[`(simref) <- value}: Equivalent of \link[base]{"[<-"}

\item \code{Ops(simref)}: Equivalent of \link[base]{Ops}

\item \code{Math(simref)}: Equivalent of \link[base]{Math}

\item \code{t(simref)}: Equivalent of \link[base]{t}

\item \code{diff(simref)}: Equivalent of \link[base]{diff}

\item \code{Summary(simref)}: \link{Summary} operations are not invertible and will throw an error.

}}
\examples{
s <- simref(4)
s2 <- 2 * s[1:2] + 1
s2[] <- 7
s ## 3 3 NA NA
## Random walk
func <- function(p) {
  u <- p$u
  ans <- -dnorm(u[1], log=TRUE) ## u[1] ~ N(0,1)
  ans <- ans - sum(dnorm(diff(u), log=TRUE)) ## u[i]-u[i-1] ~ N(0,1)
}
obj <- MakeADFun(func, list(u=numeric(20)), random="u")
obj$simulate()
}
